<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .controls {
            position: absolute;
            float: left;
            width: 20%;
            /* height: 40%; */
            top: 6.25%;
            background-color: rgba(50,50,50,0.5);
            /* display: none; */
            color: white;
        }
        .controlTitle {
            position: absolute;
            width: 20%;
            height: 5%;
            float: left;
            color: white;
            text-align: center;
            font-weight: bold;
            z-index: 2;
            font-size: 2vw;
        }
        .controlTitle:hover {
            background-color: rgba(50,50,50,0.5);
        }
        input {
            width: 100%;
        }
        .slidercontainer {
            padding: 1.5% 10%;
            font-size: 1.5vw;
        }
        .referenceDiv {
            position: fixed;
            bottom: 0%;
            color: white;
            width: 30%;
            left: 35%;
            text-align: center;
            font-size: 1.5vw;
            opacity: 0.5;
        }
        .timeStepDiv {
            position: fixed;
            bottom: 0%;
            color: white;
            /* width: 20%; */
            right: 0%;
            text-align: center;
            padding-right: 1%;
            font-size: 1.5vw;
            opacity: 0.5;
        }
        .loadingScreen {
            position: fixed;
            width: 100%;
            height: 100%;
            background-color: white;
            color: black;
            z-index: 3;
            padding: auto auto;
        }
    </style>
</head>
<body>
    <div class="loadingScreen">
        Loading...
    </div>
    <!-- <div class="controlTitle">Change Elements</div> -->
    <div class="controls">
        <div class="slidercontainer">
			<p><em>a</em>: <span>42164</span> km</p>
			<input type="range" class="slider" min="6600" max="50000" value="42164" step="1">
		</div>
        <div class="slidercontainer">
			<p><em>e</em>: <span>0.00</span></p>
            <input type="range" class="slider" min="0" max="0.9" value="0" step="0.01">
		</div>
        <div class="slidercontainer">
			<p><em>i</em>: <span>0.0</span> deg</p>
			<input type="range" class="slider" min="0" max="180" value="0" step="0.1">
		</div>
        <div class="slidercontainer">
			<p><em>&#937</em>: <span>0.0</span> deg</p>
			<input type="range" class="slider" min="0" max="360" value="0" step="0.1">
		</div>
        <div class="slidercontainer">
			<p><em>&#969</em>: <span>0.0</span> deg</p>
			<input type="range" class="slider" min="0" max="360" value="0" step="0.1">
		</div>
    </div>
    <div class="referenceDiv">
        Earth-Centered <span>Inertial</span>
    </div>
    <div class="timeStepDiv">
        Time Step: <span>60</span> sec
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.2/math.min.js"></script>
    <script src="SupportLibraries/astroFunctions.js"></script>
    <script type="module">
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/build/three.module.js';
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/controls/OrbitControls.js';
        
        var time = {
            year: 2020,
            month: 6,
            day: 1,
            hour: 0,
            minute: 0,
            second: 0
        }
        
        var orbitParams = {
            a: 42164,
            e: 0,
            i: 0,
            raan: 0,
            arg: 0,
            mA: 0
        }

        var Earth, clouds, sidTime, stopRotate, Sunlight, stars, sunVec, satPoint, orbit = undefined, r = 2, scene, camera, renderer, controls, ecef = false, timeStep = 60;
        var jdUTI0 = julianDateCalcStruct(time);
        
        setupScene();
        drawEarth();
        drawStars();
        drawLightSources();
        drawOrbit(orbitParams);
        drawAxis();
        // drawTube();

        var render = function() {
            renderer.render(scene,camera);
            controls.update();
            requestAnimationFrame(render);
            // line.attributes.position.
            // orbitParams.raan += 0.1;
            orbitParams.mA += timeStep*180/Math.PI*Math.sqrt(398600.4418/Math.pow(orbitParams.a,3));;
            // console.log(orbitParams.mA)
            sidTime += timeStep/86164*360;
            if (!ecef){
                Earth.rotation.y += timeStep/86164*2*Math.PI;
                clouds.rotation.y += timeStep/86164*2*Math.PI;
            }
            else {
                let curSun = Eci2Ecef (sidTime, sunVec);
                console.log(sidTime);
                
                // console.log(Sunlight);
                Sunlight.position.x = -100*curSun[0][0];
                Sunlight.position.y = 100*curSun[2][0];
                Sunlight.position.z = 100*curSun[1][0];
                stars.rotation.y -= timeStep/86164*2*Math.PI;
                // Sunlight.position = new THREE.Vector3(0,100,0);
            }
            drawOrbit(orbitParams) 
        }

        render();

        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight);
            camera.position.set( 0, 0, 10 );
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth,window.innerHeight);
            $('body').append(renderer.domElement);
            window.addEventListener('resize',() => {
                renderer.setSize(window.innerWidth,window.innerHeight);
                camera.aspect = window.innerWidth/window.innerHeight;

                camera.updateProjectionMatrix();
            })
            
            controls = new OrbitControls(camera,renderer.domElement);
        }

        function drawOrbit(orbitParams) {
            let tA = Eccentric2True(orbitParams.e,solveKeplersEquation(orbitParams.mA*Math.PI/180,orbitParams.e))
            let period = 2*Math.PI*Math.sqrt(Math.pow(orbitParams.a,3)/398600.4418);
            let coe = [orbitParams.a, orbitParams.e, orbitParams.i*Math.PI/180, orbitParams.raan*Math.PI/180, orbitParams.arg*Math.PI/180, tA]
            let r,r0;
            var points = [];
            
            for (var ii = 0; ii <= 200; ii++) {
                r = Coe2PosVel(coe);
                r = r[0];
                if (ecef) {
                    // console.log(r);
                    
                    r = Eci2Ecef (sidTime-ii*0.5*period/199*360/86164, r)
                    
                }   
                if (ii === 0) {r0 = r;}
                // console.log(r0);
                
                points.push( new THREE.Vector3( -r[0][0]/6371, r[2][0]/6371, r[1][0]/6371 )); 
                
                coe = twoBodyProp(coe,-0.5*period/199);
               }
            if (orbit === undefined){ 
                var material = new THREE.LineBasicMaterial({
                    color: 0x1e90ff,
                    linewidth: 30
                });
                var geometry = new THREE.BufferGeometry().setFromPoints( points );
                orbit = new THREE.Line( geometry, material );
                var geometry = new THREE.SphereGeometry( 0.05, 6, 6 );
                var material = new THREE.MeshBasicMaterial({
                    color: 0x1e90ff});
                satPoint = new THREE.Mesh( geometry, material );
                // coe = [orbitParams.a, orbitParams.e, orbitParams.i*Math.PI/180, orbitParams.raan*Math.PI/180, orbitParams.arg*Math.PI/180, tA]
                // r = Coe2PosVel(coe);
                satPoint.position.x = -r0[0][0]/6371;
                satPoint.position.y = r0[2][0]/6371;
                satPoint.position.z = r0[1][0]/6371;

                scene.add(satPoint);
                scene.add(orbit);
            }
            else {
                // Edit orbitVar
                orbit.geometry.setFromPoints(points);
                satPoint.position.x = -r0[0][0]/6371;
                satPoint.position.y = r0[2][0]/6371;
                satPoint.position.z = r0[1][0]/6371;
            }
        }

        function drawEarth(){
            var texture = new THREE.TextureLoader().load( 'https://pkevz90.github.io/pkevz.github.io/2_no_clouds_4k.jpg' );
            var cloudsTexture = new THREE.TextureLoader().load('https://pkevz90.github.io/pkevz.github.io/fair_clouds_4k.png');
            var geometry = new THREE.SphereGeometry( 1, 64, 64 );
            var material = new THREE.MeshLambertMaterial( {
                map: texture
            } );
            Earth = new THREE.Mesh( geometry, material );
            scene.add(Earth);
            clouds = new THREE.Mesh(
                new THREE.SphereGeometry(1.003, 64, 64),			
                new THREE.MeshPhongMaterial({
                    map:  cloudsTexture,
                    transparent: true
                })
		    );	
            scene.add(clouds);
            Earth.position.z = 0;
            sidTime = thetaGMST(jdUTI0);
            Earth.rotation.y += Math.PI+sidTime*Math.PI/180;
            clouds.rotation.y += Math.PI+sidTime*Math.PI/180;
        }
        
        function drawAxis() {
            var geometry = new THREE.BoxGeometry(2, 0.05, 0.05);
            var material = new THREE.MeshLambertMaterial();
            var eciX = new THREE.Mesh(geometry,material);
            eciX.position.x = -1;
            geometry = new THREE.BoxGeometry(0.05, 2, 0.05);
            var eciY = new THREE.Mesh(geometry,material);
            eciY.position.y = 1;
            geometry = new THREE.BoxGeometry(0.05, 0.05,2);
            var eciZ = new THREE.Mesh(geometry,material);
            eciZ.position.z = 1;
            scene.add(eciX);
            scene.add(eciY);
            scene.add(eciZ);
        }
        
        function drawTube() {
            var curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3( -10, 0, 10 ),
                new THREE.Vector3( -5, 5, 5 ),
                new THREE.Vector3( 0, 0, 0 ),
                new THREE.Vector3( 5, -5, 5 ),
                new THREE.Vector3( 10, 0, 10 )
            ]);
            var geometry = new THREE.TubeGeometry(curve, 20, 0.5, 8, true);
            var curveMesh = new THREE.Mesh(geometry,new THREE.MeshLambertMaterial());
            scene.add(curveMesh);
            console.log(curveMesh);
            

        }
        
        function drawStars(){
            var starTexture = new THREE.TextureLoader().load( 'https://pkevz90.github.io/pkevz.github.io/galaxy_starfield.png' );

            stars = new THREE.Mesh(
                new THREE.SphereGeometry(90, 64, 64), 
                new THREE.MeshBasicMaterial({
                    map: starTexture,     
                    side: THREE.BackSide
                })
            );
            scene.add(stars);
        }

        function drawLightSources() {
            Sunlight = new THREE.PointLight(0xFFFFFF, 1, 500);
            sunVec = sunVectorCalc(jdUTI0);
            console.log(sunVec);
            console.log(math.norm(math.squeeze(sunVec)));
            
            Sunlight.position.set(-100*sunVec[0][0],100*sunVec[2][0],100*sunVec[1][0]);
            scene.add(Sunlight);
            var light1 = new THREE.AmbientLight( 0xFFFFFF,0.2 ); // soft white light
            scene.add( light1 );
        }
    
        $('input').on('input',()=>{
            orbitParams = {
                a:      Number($('input')[0].value),
                e:      Number($('input')[1].value),
                i:      Number($('input')[2].value),
                raan:   Number($('input')[3].value),
                arg:    Number($('input')[4].value),
                mA:     orbitParams.mA
            }
            for (var ii = 0; ii < 5; ii++) {
                $('.controls span')[ii].textContent = $('input')[ii].value;
            }
            drawOrbit(orbitParams);
        })

        document.addEventListener('keypress', function(key){
            let k = key.key;
            if (k.toLowerCase() === 'e') {
                ecef = !ecef;
                if (ecef) {
                    $('.referenceDiv span')[0].textContent = 'Earth-Fixed';
                    Earth.rotation.y  = Math.PI;
                    clouds.rotation.y = Math.PI;
                }
                else {
                    $('.referenceDiv span')[0].textContent = 'Inertial';
                    Earth.rotation.y  = sidTime*Math.PI/180+Math.PI;
                    clouds.rotation.y = sidTime*Math.PI/180+Math.PI
                    Sunlight.position.x = -100*sunVec[0][0];
                    Sunlight.position.y = 100*sunVec[2][0];
                    Sunlight.position.z = 100*sunVec[1][0];
                }
            }
            if (k === '.' || k === '>') {
                timeStep += 10;
                $('.timeStepDiv span')[0].textContent = timeStep.toFixed(0);
            }
            if (k === ',' || k === '<') {
                timeStep -= 10;
                $('.timeStepDiv span')[0].textContent = timeStep.toFixed(0);
            }
        
        });

        window.addEventListener('load', (event) => {
            $('.loadingScreen').fadeOut(500);
        });
    </script>
</body>
</html>